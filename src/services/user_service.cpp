// services/user_service.cpp
module;

#include <SQLiteCpp/SQLiteCpp.h>

import std;

import user;
import user_repository;
export module user_service;

// rewrite pls
// class UserService {
//   private:
// 	UserRepository &repo_;

//   public:
// 	explicit UserService(UserRepository &repo) : repo_(repo) {
// 	}

// 	// Business methods
// 	std::optional<User> getUser(int id);
// 	std::vector<User> getAllUsers();
// 	User createUser(const std::string &name);
// 	bool updateUser(int id, const std::string &name);
// 	bool deleteUser(int id);

// 	// Business rules/validation
// 	bool validateUserName(const std::string &name);
// 	int getUserCount();
// };

// std::optional<User> UserService::getUser(int id) {
// 	if (id <= 0)
// 		return std::nullopt;
// 	return repo_.findById(id);
// }

// std::vector<User> UserService::getAllUsers() {
// 	return repo_.findAll();
// }

// User UserService::createUser(const std::string &name) {
// 	if (!validateUserName(name)) {
// 		throw std::invalid_argument("Invalid user name");
// 	}

// 	User user{0, name}; // id will be generated by DB
// 	int new_id = repo_.create(user);
// 	return User{new_id, name};
// }

// bool UserService::updateUser(int id, const std::string &name) {
// 	if (id <= 0 || !validateUserName(name)) {
// 		return false;
// 	}

// 	auto existing = repo_.findById(id);
// 	if (!existing) {
// 		return false;
// 	}

// 	User updated = *existing;
// 	updated.name_ = name;
// 	return repo_.update(updated);
// }

// bool UserService::deleteUser(int id) {
// 	if (id <= 0)
// 		return false;
// 	return repo_.deleteById(id);
// }

// bool UserService::validateUserName(const std::string &name) {
// 	// Basic validation rules
// 	if (name.empty() || name.length() > 100) {
// 		return false;
// 	}

// 	// Check for at least one non-space character
// 	return std::any_of(name.begin(), name.end(), [](char c) { return !std::isspace(static_cast<unsigned char>(c)); });
// }

// int UserService::getUserCount() {
// 	return repo_.count();
// }